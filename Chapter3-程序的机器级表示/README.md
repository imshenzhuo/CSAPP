# 程序的计算机表示

什么是机器码？什么是编译器？高级程序语言到机器码的过程

高级语言vs低级语言：效率更高更可靠

为什么还要学低级语言呢？

1. 写更高效的代码
2. 看被高级语言屏蔽的底层(比如 并发)
3. 攻击内容系统程序的漏洞需要底层知识

两个汇编语言

1. Intel IA32   --> Intel Architecture 32-bit
2. x86-64

## 主要内容

- C语言、汇编、机器代码之间的关系
- 数据的表示、处理、控制的实现 IA32
- C语言控制结构的实现
- C语言栈
- 数组、结构体、联合的实现
- 解决问题：存储器访问越界、stack overflow 攻击
- 32位---64位

## 3.2 程序编码

``` bash
unix> gcc -O1 -o p p1.c p2.c
```

从`.c`到可执行文件，各个主角依次登场

- C预处理器
- 编译器
- 汇编器
- 链接器

#### 代码示例

- 生成汇编文件
- obj文件可执行文件反汇编生成汇编文件

#### 数据格式

- 汇编后缀b 字节 char 
- 汇编后缀w 字 2字节 16位
- 汇编后缀l 字 4字节 32位

#### 汇编回顾

##### 寻址

##### 数据传送

- mov
- movs 小数据-> 大数据
- movz 小数据-> 大数据
- push/pop

示例：从汇编理解指针

从汇编反推C语言代码

### 3.6 控制

#### 控制的元依赖-条件码

更改条件码方法

- 正常运算
- 设置set
- 条件使用 CMP、TEST

#### C语言控制语句

即使简单如if，也同样使用了goto语句

循环的顺序是 do-while while for，依次向上，任何循环汇编的底层都是do-while结构

#### 条件传送 -- 比较高级的策略

#### switch 语句

switch底层并不是重复的if-else，从汇编代码中可以看出，switch使用了跳转表，表的key是连续的switch的选项，value是对应的地址

相对于if-else的逐个遍历，当switch的选项跨度较小，开关数量多的情况下，switch更高效。

### 3.7 过程 proc

6/25早晨花了不到两个小时搞清楚了C语言函数跳转的底层实现原理

#### 栈帧的结构

IA32用程序栈支持调用，地址越小，越靠近栈顶，每一个函数都是一个栈帧，栈帧的结构一般为：帧指针%ebp、参数、栈指针。ps 帧指针和栈指针不是栈帧的内容，而是指向栈帧不同位置的两个指针。

帧指针：帧指针内保存了栈帧的底的地址 帧指针所指的内容中存储了上一个栈帧的帧指针，还用作参数地址的基准 

栈指针：栈指针保存了栈顶的地址，出现在当前活跃的栈帧中

#### 转移控制

- call
- leave
- ret

leave等价于

``` assembly
movl	%ebp	%esp
# 将帧指针存的内容（当前帧的首地址）赋值到 栈指针指向的内容（栈顶地址）
# 即 栈顶回退到帧首地址
popl	%ebp
# 将原来保存的复原，帧指针重新指向新的帧的首地址
```

#### 寄存器使用惯例

有的硬件自动还原，有的要手动还原

#### 递归

pass

### 数组内部

复习了数组和指针

利用底层知识，举了二维数组的操作被优化的例子

结构体就是加了对齐机制的可以存多种数据类型的数组
ps 不只是数据类型有对齐，帧栈也是

联合用途在于：

- 丧心病狂节省存储空间，锱铢必较
- 避开C语言数据类型的检查









​                                                                                                                           