# 计算机系统漫游

硬件+软件组成了`计算机系统`，在计算机系统上运行`Application` , 虽然计算机技术更新很快，系统的内在概念却没有改变。

**将会学到的东西**

- 避免奇怪的数字错误----数字编码----共享单车账单上的9999
- 优化C代码----现代处理器和存储器系统
- 避免buffer溢出----编译器实现调用
- 避免链接错误----链接
- 编写自己的`shell` 、动态存储分配包、Web服务器
- 并发的好消息和坏消息

## `信息`就是bit+context

在不同的上下文中，一个相同的字符序列可能是一个整数，也可能是一个浮点数

## 从编写到执行

``` shell
$ linux> gcc source_file_name.c -o exe_file_name
# 举例来说
$ linux> gcc hello.c -o hello
```

C语言的源程序是给人看到，计算机可不认识它，所以就需要一个很NB的东西把人能看懂的翻译成机器可以看懂的，这就是`编译系统`。

从`hello.c`到`hello`共有四个阶段

1. 预处理器 --> 预处理  插入头文件、替换#define等 xx.c -> xx.i
2. 编译器 --> 编译 翻译为汇编语言 xx.c -> xx.s
3. 汇编器 --> 汇编 xx.s -> 机器指令 (打包)-> xx.o（binary file）
4. 链接器 --> 链接 hello.o -> hello 将hello.o与hello内调用的库文件以某种方式合并

## 了解`编译系统`

- 性能优化
  - switch是否总是比if-else高效
  - 一个函数的开销到底有多大
  - while循环 vs for循环
  - 指针引用 vs 数组引用
  - 为什么简单排列一些括号可以让函数运行的更快
- 理解链接时候的错误
  - 静态？全局？
  - 两个全局重名？
  - 静态库？动态库？
- 避免安全漏洞

## `hello`的执行

``` shell
linux> ./hello
hello, world
```

## 缓存

程序越来越倾向于访问局部区域里的代码和数据，所以就有了高速缓存Cache（SRAM）

> 意识到 Cache的应用程序员可以根据 Cache 的性能提高一个数量集

## 存储设备层次结构

寄存器 -> L1 Cache -> L2 Cache -> L3 Cache -> 主存 -> 本地磁盘 -> 远程数据

> 同样可以利用存储设备的层次结构来提高程序性能

## 操作系统管理硬件

`hello`程序

### 进程

进程 = 处理器 + 虚拟内存

并发运行：两个进程指令交错执行

### 线程

### 虚拟内存

为每个进程提供其在独立地使用主存的假象

### 文件

文件就是字节序列

## 网络通信

## 重要主题

### Amdahl定律

### 并发和并行

 	